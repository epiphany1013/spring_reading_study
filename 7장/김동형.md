 # 스프링 삼각형과 설정 정보
<br/>
  
 * 스프링을 이해하는 데는 POJO(Plain Old Java Object)를 기반으로 스프링 삼각형이라는 애칭을 가진 IOC/DI, AOP, PSA라고 하는 스프링의 3대 프로그래밍 모델에 대한 이해가 필수다.<br/>
 
 ## IoC/DI - 제어의 역전/의존성 주입
- 스프링의 ioC(Inversion of Control/ 제어의 역전), DI(Dependency Injection/의존성 주입)을 알아보기 전에 프로그래밍에서 의존성이 무엇인지 자바에서의 의존성은 무엇인지 알아보자.

```text
  의사 코드

  - 운전자가 자동차를 생산한다.
  - 자동차는 내부적으로 타이어를 생산한다.
```
```java
  위 문장을 자바로 표현

  - new Car();
  - Car 객체 생성자에서 new Tire();
```
위 코드에 대한 의존성을 단순하게 정의하면<br/>
* 의존성은 new다. 
* new 를 실행하는 Car와 Tire 사이에서 Car가 Tire에 의존한다.<br/>

  결론적으로 전체(Car)가 부분(Tire)에 의존한다라고 표현할 수 있다.<br/>

이제 실제 코드로 알아보자<br/>

Tire 인터페이스
```java
 public interface Tire {
	String getBrand();
}
```
KoreaTire 클래스
```java
 public class KoreaTire implements Tire {
	public String getBrand() {
		return "코리아 타이어";
	}
}
```
AmericaTire 클래스
```java
 public class AmericaTire implements Tire{
	public String getBrand() {
		 return " 미국 타이어";
	}
}
```
Car 클래스(변경 전) 
```java
 public class Car {
	Tire tire;
	
	public Car() {
		tire = new KoreaTire();
	//  tire = new AmericaTire();
	}
	
	public String getTireBrand() {
		return "장착된 타이어: " + tire.getBrand(); 
	}
}
```
Driver 클래스(변경 전)
```java
 public class Driver {
	public static void main(String[] args) {
		Car car = new Car();
		
		System.out.println(car.getTireBrand());
	}
}
```

위 코드에서 주의 깊게 볼 부분을 Car 클래스이다. 
```java
 new KoreaTire()
```
이 부분에서 자동차가 타이어를 생산(new)하는 부분, 즉 의존 관계가 일어나고 있는 것이다.

### 스프링 없이 의존성 주입하기1 - 생성자를 통한 의존성 주입

* 주입이란?
  - 주입이란 말은 외부에서라는 뜻을 내포하고 있는 단어다.
  - 결국 자동차 내부에서 타이어를 생산하는 것이 아니라 외부에서 생산된 타이어를 자동차에 장착하는 작업이 주입이다.

위 코드에서 생성자를 통한 의존성을 주입해보자.<br/>

```text
  의사 코드

  - 운전자가 타이어를 생산한다.
  - 운전자가 자동차를 생산하면서 타이어를 장착한다.
```
```java
  위 문장을 자바로 표현

  - Tire tire = new KoreaTire();
  - Car car = new Car(tire);
```

Car 클래스(변경 후) 
```java
 public class Car {
	Tire tire;
	
	public Car(Tire tire) {
		this.tire= tire;
	}
	
	public String getTireBrand() {
		return "장착된 타이어:" + tire.getBrand();
	}
}

```
Driver 클래스(변경 후)
```java
 public class Driver {
	public static void main(String[] args) {
		Tire tire = new KoreaTire();
		//Tire tire = new America();
		Car car = new Car(tire);
		
		System.out.println(car.getTireBrand());
	}
}
```
(변경 전)코드와 비교했을떄 (변경 후)코드의 Car 클래스 생성자 부분이 달라졌다 new가 사라지고 생성자에 인자가 추가된 것을 볼 수 있다.<br/>
그리고 new를 통한 타이어를 생산하는 부분이 Car 클래스에서 드라이버 클래스로 이동한 것을 볼 수 있다.

 * 기존 코드에서는 Car클래스가 구체적으로 KoreaTire를 생산할지 AmericaTire을 생산할지 결정을 해야하기에 유연성이 떨어진다고 한다.
 * 위 변경된 코드를 현실세계에 비유하면 자동차가 생산될 때 어떤 타이어를 생산해서 장착할지를 자동차가 스스로 고민하지 않고 운전자가 차량을 생산할 때 운전자가 어떤 타이어를 장착할지 고민하는것이다.</br>
 
 즉 자동차는 어떤 타이어를 장착할까를 고민을 안해도 된다.





 
 
