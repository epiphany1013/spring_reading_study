자바 클래스와 관련된 객체 지향 개념들을 더 잘 알게 되었다

# 3장 자바와 객체 지향

## 객체 지향은 인간 지향이다

우주 만물은 결국 객체로 이루어져 있고 인간은 이 객체들을 인지하는 방식으로 세계를 받아들인다.
-> 이 방식 그대로 프로그래밍 할 수 있지 않나? 라는 발상이 객체 지향의 시작이다.
그러므로 매우 직관적이다.

즉 이를 정리하면
```
세상에 존재하는 것은 모두 사물
각각의 사물은 고유하다.
사물은 속성을 갖는다.
사물은 행위를 한다.
```
를 생각해볼 수 있고 이 사물들을 분류해서 인식하는 것이 class라고 할 수 있다.

```
사람이라는 분류 안에는 김종민, 한효주, 김연아라는 object가 있다. 
각각의 객체들은 나이, 몸무게, 키 등의 속성(property)을 가지며 각종 행위들(method)을 한다.
```

## 객체 지향의 4대 특성: 캡!상추다

객체 지향의 4대 특성을 섞어서 기억하는 경우가 많았는데, 이번 기회에 좀 더 구분해서 알게 되었다.

여기서 캡!상추다는 앞글자를 딴 줄임말인데
```
캡 - 캡슐화(Encapsulation): 정보 은닉
상 - 상속(Inheritance): 재사용
추 - 추상화(Abstraction): 모델링
다 - 다형성(Polymorphism): 사용편의
```
여기서 Inheritance는 오해를 불러들일 수도 있어서 저자는 다른 단어를 제안한다.

## 클래스는 금형기계가 아니다.

객체를 하나 만드는 코드는 아래와 같다
```java
클래스 객체명 = new 클래스();
```

그런데 클래스를 붕어빵틀이라고 한다면?

```java
금형기계 붕어빵틀 = new 금형기계();
```
이를 해석해보자면
```
새로운 금형기계를 하나 만들었더니 붕어빵틀이 되었다.
```
로 어색한 표현이 된다.
즉 금형기계와 붕어빵틀은 클래스와 객체 관계로 보기 어색하다.

다음으로 아리송한 질문들이라고 처음엔 느꼈었는데, 명확하게 잘 이해간 설명이 있었다.

- 사람은 클래스인가? 객체인가?
- 김연아는 클래스인가? 객체인가?
- 뽀로로는 클래스인가? 객체인가?
- 펭귄은 클래스인가? 객체인가?

이 질문들에 아주 간단하게 대답하는 방법은 나이를 물어보면 된다.
객체라면 고유한 속성인 나이를 갖고 있으므로 나이를 알 수 있다. 즉 김연아와 뽀로로(몰라도 검색하면 알 수 있으니)는 객체이지만 사람과 펭귄은 클래스이다.
즉 클래스는 분류에 대한 개념이고 객체는 그 실체다.

## 추상화: 모델링


추상화: 사물의 사실적 재현이 아니고 순수한 점.선.면.색채에 의한 표현을 목표로 한 그림. 일반적으로는 대상의 형태를 해체한 입체파 등의 회화도 포함된다.

미술 용어를 이해하면서 프로그래밍 용어인 추상화를 생각하면 더 쉽게 이해 된다. 추상화는 객체들을 총칭하기 위해 클래스를 설계할 때 완전한 사실적 재현이 아니라 관심 사항에 맞게(프로그램이라면  애플리케이션 영역이라고 한다.) 재조합하는 것이다.

```
예를 들어 일반적으로 사람 클래스의 속성을 적어보자면 시력, 몸무게, 혈액형, 키, 나이, 직업, 연봉 ...
이 있다.

은행 어플리케이션이라면 시력, 몸무게, 혈역행, 키 등의 정보는 은행 어플리케이션의 목적에 부합하지 않는다.
병원 어플리케이션이라면 직업, 연봉의 정보는 병원 어플리케이션의 목적에 부합하지 않는다.
즉 어떤 어플리케이션이냐에 따라 클래스의 설계는 달라지게 된다.
```

즉 실제 사물을 정확히 복제하는게 아닌, 목적에 맞는 관심 있는 특성만을 추출해서 표현 한 것이다.
이런 모델링이 바로 객체 지향에서 클래스를 설계, 데이터베이스 테이블을 설계할 때 필요한 기법이다.

```java
클래스 객체명 = new 클래스();
```
을 더 뜯어보자.
- 클래스: 객체의 자료형(type)
- 객체명: 객체 참조 변수로, 생성된 객체를 참조할 수 있는 변수이다.(후에 메모리 그림을 보면 이해가 쉽다.)
- =: 할당문
- new: 새로운
- 클래스: 만들고자 하는 객체의 분류
- (): 메서드

## T 메모리 구조와 클래스
들어가기 전

```text
프로그램이 메모리를 사용하는 방식
코드 실행 영역, 데이터 저장 영역으로 나뉘는데 
객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역(Static, Stack, Heap) 
으로 나누어서 사용한다. -> 이를 T 메모리 구조라고 함.
여기서 스태틱 영역을 클래스들의 놀이터, 스택 영역을 메서드들의 놀이터, 힙 영역을 객체들의 놀이터라고 생각하면 된다.
```
를 다시 떠올리자.

```java
Mouse Mickey = new Mouse();
```
```
[한 마리 쥐(클래스)][클래스의 인스턴스]가 태어났으니 그 이름을 mickey(객체 참조 변수)라 하였다.
```
의 내용을 하나하나 뜯어보면
- Mouse mickey: Mouse 객체에 대한 참조 변수 mickey를 만든다.
- new Mouse(): Mouse 클래스의 인스턴스를 하나 만들어 힙에 배치한다.
- =(대입문): Mouse 객체에 대한 주소를 참조 변수에 할당한다.

이 명령이 실행될 때 T 메모리가 어떻게 되는지 살펴보면,
Mouse mickey가 실행 될 때 main() 스택 프레임에 mickey 변수의 저장 공간이 만들어진다.
그 후 new Mouse()의 구문이 실행 될 때 힙 영역을 사용하게 된다.
그리고 할당을 해주게 되면 객체 참조 변수 mickey에 Mouse 객체의 주소를 넣게 되니, 이 주소를 통해서 Mouse 객체를 참조하게 된다. -> 객체 참조 변수 mickey는 Mouse 클래스의 인스턴스를 참조한다.

그 후 이 Mouse의 객체에 이름, 나이, 꼬리숫자를 입력하게 되면, 힙 영역에 저장 공간에 그것들을 저장하게 되고 main() 스택 프레임의 mickey는 그것을 주소를 통해 참조하는 것이다.

여기서 mickey에 null을 할당하면 어떻게 될까? 더 이상 힙 영역의 Mouse의 객체를 참조하지 않게 되고 Garbage Collector가 Mouse 객체를 수거해 간다. (언제 다녀갔는지는 정확히 알 수 없다.)


## static을 왜 쓰는지 알아보자.

단순히 고정된 값은 static.. 암기식으로 알고 있었지만 다음의 설명들을 보고 생각이 바뀌었다.
```
미키마우스의 꼬리는 몇 개인가요?
```
무조건 한 개다.
이렇게 한 개로만 답할 수 있는 것을, 만약 T 메모리에서 모든 객체 수만큼 저장공간을 쓰고 있다면? 낭비이다. 그러므로 이 값을 '클래스'에 하나만 저장하는 것이고 그것이 static이다. 이렇게 static 키워드를 붙인 속성을 클래스 멤버 속성이라고 하고 안 붙인 것을 객체 멤버 속성이라고 보면 된다.(클래스 멤버 메서드, 객체 멤버 메서드)

클래스 멤버는 정적 멤버라는 표현으로도 말할 수 있는데 정적 멤버라는 말을 더 많이 쓴다.
여기서 정적 멤버는 JVM 구동 시 T 메모리의 스태틱 영역에 바로 배치 되므로, 객체가 없더라도 사용할 수 있다. 이런 예시는 뭐가 있을까? 바로 main() 메서드와 Math 클래스에 있는 정적 메서드들에서 그 예시를 알 수 있다. 객체 속성과 정적 멤버 속성에 관해 한 가지 더 기억해야 할 것은 객체 속성은 힙 영역에 객체가 생성될 때 각 객체 안에 멤버 속성을 위한 메모리 공간이 할당 되된다. 스태틱 영역에서는 객체 속성명만 있다는 것이다.


## 지역변수와 클래스 변수/객체 변수의 차이

지역 변수는 해당 지역에서만 사용하기 때문에 별도로 초기화 해야하는데 클래스 변수와 객체 변수는 공유 변수의 성격을 갖고 있기 때문에 (객체 변수:다수의 객체 메서드가 사용 / 클래스 변수: 전역변수처럼 프로그램 어디서든 접근 가능한 공유 변수) 초기화를 하지 않아도 기본값으로 초기화가 된다.

## 상속: 재사용 + 확장
앞서서 inheritance가 왜 오해를 불러 일으키는지 알 수 있다.
상속이란 말을 떠올리면 가족 관계도를 떠올렸었다. 하지만 프로그래밍, 객체 지향에서의 상속이란  동물, 포유류, 조류, 고래, 박쥐, 참새...가 있는 분류도가 알맞다.
```
포유류는 동물의 특성을 '확장'한 것이고 고래는 '포유류'의 특성을 확장한 것이다. 
즉 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고, 거기에 필요한 특성을 추가(즉 확장)해서 사용할 수 있는 것이다.
```
이런 이유로 자바에서 상속을 할 때 'extends'라는 키워드를 사용한다.

## 상속의 강력함

상속을 통해서 상위 클래스에서 구현된 메서드를 하위 클래스 각각 원하는 바에 맞게 재작성 없이
실행 가능하다.

[p114 이해가 잘 안감 왜 이 코드를 보고 더 잘 이해한다고 한건지..]

- 객체 지향의 상속은 상위 클래스의 특성을 재사용 하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

## 다중 상속 대신 인터페이스를 쓰는 자바

C++에서 인어가 사람, 물고기를 다중 상속하고 있다면? 인어가 수영을 할 때 사람처럼 팔과 다리를 저어 수영할까? 물고기처럼 지느러미로 헤엄칠까? 이런 문제를 자바에서는 인터페이스로 해결하고 득만 취하기로 한다.

자바에서의 다중 상속 표현
```
- 인터페이스: 구현 클래스 is able to 인터페이스
- 해석: 구현 클래스는 인터페이스 할 수 있다.
- 예제: 고래는 헤엄칠 수 있다.
```

자세히 모를 때는 상속이 있는데 굳이 왜 인터페이스를 쓰지? 했었다.
상속과 인터페이스의 차이는, 상위 클래스는 하위 클래스에게 속성과 메소드를 상속해주는 것이고
인터페이스는 클래스가 '무엇을 할 수 있다' 라고 하는 기능을 강제로 구현하게 한다.

## 상속과 T 메모리

Penguin 클래스가 Animal 클래스를 상속하고 있다고 해보자. 그리고
```java
Penguin pororo = new Penguin();
```
로 객체 참조 변수를 만들었다면?
Penguin 객체만 힙 영역에 생기는 것이 아니라 상위 클래스인 Animal도 힙 영역에 같이 생기게 된다.(모든 클래스의 최상위 클래스 Object도 항상 함께 생성됨)

```java
Animal pingu = new Penguin();
```
이렇게 객체 참조 변수를 만든다면?
pingu 객체 참조 변수는 Animal 객체를 가르키게 된다. (잘 이해 안 감 질문하자)

## 다형성: 사용 편의성
### 오버라이딩과 오버로딩
굳이 같이 있어서 더욱 헷갈릴 수 있는 말인데, 설명을 보고 간단하게 이해됐다.
```
오버로딩은 적재를 더하는 것이다. 즉 메서드에 파라미터를 더 적재하는 모습을 떠올리면 된다.
오버라이딩은 올라타서 메서드를 재정의하는 것이다.(인자 목록 변화X)
```
상위 클래스에서 정의된 메서드를, 하위 클래스에서 오버라이딩으로 재정의하면 하위 클래스 타입에 맞게 알아서 메소드가 실행된다. 이것이 사용 편의성이다.
[p133 상위 클래스 타입의 ~ 호출 된다는 사실] 이거 잘 이해가 안 간다. 왜 가려져있지?
그냥 그렇게 만든거?

```java
class SuperClass {
    String message = "SuperClass의 메세지";

    void showMessage() {
        System.out.println("SuperClass: " + message);
    }
}

class SubClass extends SuperClass {
    String message = "SubClass의 메세지";

    @Override
    void showMessage() {
        System.out.println("SubClass: " + message);
    }
}

public class Test {
    public static void main(String[] args) {
        SuperClass obj = new SubClass();
        obj.showMessage(); // 출력: SubClass: SubClass의 메세지
        System.out.println(obj.message); // 출력: SuperClass의 메세지
    }
}

```
가려진게 없으면 상위클래스의 메서드로 실행된다.
```java
class SuperClass {
    int superField=1;
    void superMethod() {
        System.out.println("SuperClass의 메서드");
    }
}

class SubClass extends SuperClass {
    int subField=2;
    void subMethod() {
        System.out.println("SubClass의 메서드");
    }
}

public class Test {
    public static void main(String[] args) {
        SuperClass obj = new SubClass();
        System.out.println(obj.superField); // 정상 작동
        obj.superMethod(); // 정상 작동, "SuperClass의 메서드" 출력

        // 다음 두 줄은 컴파일 에러가 남
//         System.out.println(obj.subField); // 컴파일 에러
//         obj.subMethod(); // 컴파일 에러
    }
}
```


## 정적 멤버 접근시에는 [클래스명.정적멤버] 형식으로

메모리 구조를 살펴보면, 클래스명.정적멤버로 접근해야 코드 실행 영역에서 바로 스태틱 영역의 정적 멤버에 바로 접근한다.
그러나 객체참조변수명.정적멤버의 형식으로 접근하면 메소드 스택 프레임에 있는 객체 참조 변수명의 주소가 가리키는 힙 영역의 클래스 객체로 간 다음 클래스 객체에서 다시 스태틱 영역의 정적 멤버로 접근하게 된다.

## Call By value vs Call By reference

```java
int a = 10;
int b = a;
b = 20
```
그럼 이후 a와 b를 출력하면 어떻게 나올까?
```java
a = 10
b = 20
```
으로 출력된다. 이처럼 int b = a; 에서 a가 가진 값이 단순히 b에 복사된 것이므로 그 이후에는 서로 영향을 주지 않는다.

하지만 이런 경우는?

```java
Animal ref_a = new Animal();
Animal ref_b = ref_a;

ref_a.age = 10;
ref_b.age = 20;
```
이제 ref_a.age와 ref_b.age의 값은 뭐가 나올까?
둘 다 20이 나오게 된다.
그 이유는 ref_a와 ref_b의 객체 참조 변수가 '''같은''' 힙 영역의 클래스 객체를 가리키고 있으므로, 둘의 값 중 하나를 바꾸게 되면 둘의 값이 모두 바뀌는 것이다. 정확히는, 둘의 값이 모두 바뀌는게 아니라 힙 영역의 Animal 객체에서 age가 바뀌고 이 하나의 객체를 둘의 객체 참조 변수가 바라보고 있는 것이므로 똑같은 값으로 나오는 것이다.
흔히 말하는 call by value는 변수에 있는 값을 그 값 자체로 판단하고,call by reference는 저장하고 있는 값을 주소로 판단, 이해한다는 말이 더욱 자세히 이해됐다.
(기본 자료형 변수 복사, 참조 자료형 변수 복사할 때 값이 똑같이 복사되는건 맞다. 그러나 그 이후의 해석이 달라지는 것이다.참조 자료형 변수는 가리키고 있는 값까지 생각해야 하므로)