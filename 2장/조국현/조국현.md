# 2장 자바와 절차적/구조적 프로그래밍


## 자바 프로그램의 개발과 구동

- JDK: 자바개발 도구(소프트웨어 개발 도구)
  JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있다.

- JRE: 자바 실행 환경(JVM용 OS, 운영체제)
  JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.

- JVM: 자바 가상 기계(가상의 컴퓨터)

## 프로그램이 메모리를 사용하는 방식

코드 실행 영역, 데이터 저장 영역으로 나뉘는데 객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역(Static, Stack, Heap) 으로 나누어서 사용한다. -> 이를 T 메모리 구조라고 함.
여기서 스태틱 영역을 클래스들의 놀이터, 스택 영역을 메서드들의 놀이터, 힙 영역을 객체들의 놀이터라고 생각하면 된다.

## 메서드 스택 프레임

```java
public class Start {
	public static void main(String[] args) {
    	System.out.println("Hello OOP!!");
    }
}
```
와 같은 코드가 메모리에서 어떤 일이 일어나며 실행되는지 살펴보면, JRE는 우선 프로그램에 main() 메서드가 있는지 확인 후 있으면 JVM에 전원을 넣어 부팅한다. 그 뒤 JVM은 목적 파일을 받은 뒤 실행시키고 java.lang 패키지(모든 자바 프로그램이 포함하는 패키지)를 T 메모리의 스태틱 영역에 갖다 놓는다. 이 덕분에 System.out.println같은 메서드를 쓸 수 있다. 그 뒤 import할 다른 클래스나 패키지들을 스태틱 영역에 놓는다. 그러므로 스태틱 영역을 클래스들의 놀이터로 이해할 수 있다.

이후 main() 메서드는 스택 영역에 할당되는데 클래스 정의하는 중괄호를 제외하면 중괄호를 만날 때마다 스택 프레임이 생긴다. 그리고 메서드의 인자 args를 저장할 변수 공간이 스택 프레임의 맨밑에 확보된다. 그 뒤 main() 메서드 안의 명령문을 실행할 수 있다. 그 뒤 main() 메서드의 끝나는 중괄호를 만나면 스택 프레임은 사라진다. ( main() 메서드의 닫는 중괄호 -> 스택 프레임 소멸 -> JRE가 JVM을 종료 -> JRE도 메모리에서 사라짐 -> T 메모리 사라짐)

## 변수가 있는 공간

```java
public class Start2 {
	public static void main(String[] args) {
    int i;
    i = 10;
    
    double d = 20.0;
    }
}
```

맨 첫 코드와 달라진 점은 이제 main() 메서드 안에 지역변수가 선언 및 초기화 되었다는 것이다. args를 위한 공간을 마련하고, 그 뒤에 변수 i를 위한 공간을 마련한 뒤(이 때는 초기화 되지 않은, 알 수 없는 garbage값을 갖고 있다.) i=10으로 초기화 해주었다. 그 뒤 double d = 20.0; 의 명령문은 앞서 변수 i를 선언하고 초기화한 과정처럼 한 줄이더라도 두 과정에 나누어져 실행된다고 보면 된다.

## 지역변수와 메모리

- 스태틱 영역: 클래스 멤버 변수, JVM이 종료될 때까지 static 상태로 그 자리에 있다.
- 스택 영역: 지역 변수, 스택 프레임이 사라지면 같이 사라진다.
- 힙 영역: 객체 멤버변수, 객체와 함께 garbage collector라는 힙 메모리 회수기에 의해 사라진다.


```text
외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하다

```
의 의미는 무엇일까? 외부 스택 프레임 코드 단계에서는 내부 스택의 중괄호가 시작이 되지 않았기 때문에 메모리 구조 자체에 내부 스택 프레임이 생기지도 않았고 변수 또한 없다. 그리고 내부 스택 프레임에 들어가더라도 닫는 중괄호로 내부 스택 프레임이 사라지므로 다시 외부 스택 프레임에서는 내부 스택 프레임 변수에 접근하는 것은 불가능하다.

역인 내부 스택 프레임에서 외부 스택 프레임의 변수에 접근하는 것은 가능하다? 왜일까?
메모리 구조를 생각해보면 단순하다. 내부 스택 프레임 단계에서는 외부 스택 프레임이 있기 때문이다.

## call by value

```java
public class Start4 {
	public static void main(String[] args) {
    	int k = 5;
        int ;
        
        m = square(k);
    }
    
private static int square(int k) {
	int result;
    k = 25;
    
 	result = k;
    
    return result;
    }
 }
 ```
call by value에 대해서 알고 있었다고 생각했는데, 구조를 통해서 보니 더 이해가 잘 되었다.
main() 메서드에서의 변수 k와 square() 메서드에서의 변수 k는 모양만 같을 뿐이지 전혀 다른 변수이다. 메모리 구조상 square()와 main() 메서드의 각각의 변수 k는 다른 구조에 속해있다. 그러므로 두 변수는 어떻게 변한다해도 서로에 영향을 주는 것이 아니다. 이를 call by value 라고 하며, 변수 자체를 인자로 전달하는 것이 아니라 단순히 값을 복제하여 전달하는 것을 말한다.

또한 이는 자바에 포인터가 없기 때문에 메서드 스택 프레임 사이에서 변수 참조가 불가능하다고도 말할 수 있다.

- 메서드를 블랙박스화 한다는 말의 의미는, 메서드 사이에서는 인자값, 반환값에 의해서만 값이 전달되고 서로의 내부 지역변수를 들여다 볼 수 없다는 것을 의미한다.


## 전역 변수 사용을 자제해야 하는 이유

전역 변수란 어느 곳에서나 접근이 가능하므로 여러 메서드들이 공유해서 사용할 수 있다. 그러므로 현업에서는 프로젝트 규모가 커져서 이 메서드, 저 메서드들이 전역 변수를 사용하다보면 전역 변수의 값이 무엇이 되었는지, 어디서 변했는지 파악하기가 힘들어진다. 그러나 전역 상수의 사용은 권장된다.(ex. Math.PI)

## 멀티 스레드 / 멀티 프로세스의 이해

이 부분도 메모리 구조의 차이를 아니깐 이해가 잘 되었다. 멀티 스레드는 스택 영역을 스레드의 개수만큼 분할해서 사용하고, 멀티 프로세스는 T 메모리 구조 자체를 여러개를 가지는 것이다. 멀티 프로세스는 다른 T 메모리 구조를 침범할 수 없으므로 안전하겠지만, 메모리 사용량은 비교적 크다. 반대로 멀티 스레드의 경우는 다른 스레드의 스택 영역에 접근할 수 없고 스태틱 영역과 힙 영역만 공유해서 사용하므로 비교적 메모리를 아낄 수 있다.
```
서블릿은 요청당 프로세스가 아닌 스레드를 생성한다. -> 요청당 스레드가 요청당 프로세스보다 더 효율적이므로
```

```java
public class Main extends Thread {
    static int share;

    public static void main(String[] args) {
        Main m1 = new Main();
        Main m2 = new Main();

        m1.start();
        m2.start();
    }

    public void run() {
        for (int count = 0; count < 10; count++) {
            System.out.println(share++);

            try {
                sleep(1000);
            } catch (InterruptedException e) {
            }
        }
    }
}
```



위의 코드에서는 m1, m2 스레드가 동시에 실행되어 share 변수에 동시에 접근하는데 이 접근이 동기화 되어 있지 않기 때문에 share의 값이 어떻게 변할지 예측하기가 힘들어진다.


자바는 메모리에 대한 주소값만 조회가 가능하지 변경은 안된다. C언어의 경우 주소값도 변경가능하다.







