# 02 자바와 절차적/구조적 프로그래밍

### 1. **자바의 구동 구조**

- 소프트웨어 개발 도구 = JDK (JVM용)
  - 자바 소스 컴파일러 포함 (javac.exe)
- 운영체제 = JRE (JVM용)
  - 자바 프로그램 실행기 (java.exe)
- 하드웨어 = JVM (가상머신)
- JDK > JRE > JVM

⇒ Write Once Run Anywhere

### 2. **프로그램의 메모리 사용 방식**

- 절차적 프로그래밍 = goto 를 쓰지 말라!
  - goto? 제어 흐름 이동
  - java: go to/ const  = not used
  - goto 를 사용하게되면 프로그램의 실행 순서가 너무 복잡해질 수 있음
- 구조적 프로그래밍 = 함수를 쓰자!
  - 함수 = method
  - 중복 코드들 관리가 쉬워짐
  - 이해하기 쉬운 코드 작성 가능
  - 공유 사용 시 지역 변수 사용
  - function 과 method의 차이점은 거의 없음
- **코드 실행 시 메모리 할당의 변화**
- T 메모리 : 자바에서의 데이터 저장 영역

```java
public class Start{
	public static void main(String[] args){
		System.out.println("HELLO OOP!");
	}
}
```

1. jre : main메서드 확인 → start 에서 확인
2. jre: jvm에 전원 넣음
3. jvm: 목적 파일 실행 → java.lang
4. jvm: java.lang 패키지를 T 메모리의 static 영역에 갖다놓음
5. jvm : 개발자가 작성한 코드와 패키지들을 static 영역에 갖다놓음
6. main() method : stack 영역에 할당
7. args 저장변수 공각 확보
8. main() 안의 첫 명령문 → println 실행
9. main() 메서드 종료
10. jre : jvm종료
11. jre: os 상의 메모리에서 제거됨
12. T 메모리 제거됨

- 위 코드에 변수가 선언될 경우

  - stack에 값 추가됨
  - 변수에 값이 없이 선언 → 쓰레기값 할당

  ⇒ 초기화 필요

- 짝이 되는 중괄호 차례가 되면 중괄호에 해당하는 클래스의 스택 프레임은 스택 영역에서 사라짐

### 3. **지역 변수**

- **static**: class 멤버 변수 - jvm 이 종료될 때까지 고정된 상태로 있음
- **stack** (stack frame): 지역 변수, stack frame 이 사라지면 함께 사라짐
  - 스택프레임: 프로그램 실행 중에 **함수 호출과 관련된 정보를 저장하는 메모리 공간**
- **heap**: 객체 멤버 변수, gc에 의해 제거됨
- 외부 스택 프레임 →  내부 스택 프레임 (지역 변수) 의 변수에 접근하는 것은 불가능
- 내부 스택 프레임 → 외부 스택 프레임의 변수에 접근하는 것은 가능
  - 외부 메서드에 의해 호출된 메서드의 경우 ( call by value ), 동일한 변수 명이어도 실제로는 다른 변수
  - **Call By Value**: 변수가 저장한 값만을 복제해서 전달
- **메서드 블랙박스화** : 메서드 사이에서는 값이 전달될 뿐 내부의 지역 변수를 볼 수 없음
- 다른 메서드가 실행되는 동안 해당 메서드를 실행한 메서드의 지역 변수를 참조할 수 없는 이유
  1. 메서드는 **서로의 고유 공간**이기 때문에
  2. 포인터 문제 - 메모리 주소 값을 알아야 하는데, 자바에는 포인터가 없음
     - 자바 참조: 읽기 전용
     - C, C++: 포인터 - 읽기, 쓰기 모두 가능
  3. 특정 메서드는 실제 상황에서는 다른 메서드들도 호출할 경우, 메서드를 호출하면서 만들어지는 스택 구조는 **항상 바뀜**

### 4. 전역 변수

- 메서드 사이 값 공유 가능
- 스택 프레임에 독립적
  - 지역 변수는 스택 프레임에 종속적

### 5. 멀티 스레드와 멀티 프로세스

- 멀티 스레드: 한 메모리를 여러 스레드끼리 나눠서 사용
  - 스택 영역만 분할해서 사용
  - 스테틱 영역과 힙 영역 공유하여 메모리 적게 사용 가능
  - **servelet**: 요청당 스레드 생성
  - 멀티 스레드 사용 시 전역변수 사용의 문제점
    - 스테틱 영역과 힙 영역을 공유하고 있기 때문에 동일
- 멀티 프로세스: 다수의 데이터 영역을 가짐
  - 서로 참조 불가
  - 메모리 사용량 큼