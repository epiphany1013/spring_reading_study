# 5장 객체 지향 설계 5원칙 - SOLID

SOLID, SOLID 자주 들었었는데 이번에 공부하면서 좀 더 명확하게 알게 되었다.


## 결합도는 낮추고, 응집도는 높여라.
이 원칙을 객체 지향의 관점에서 재정립한 것이 SOLID 원칙이다.

SOLID 원칙은?
- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open Closed Principle): 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- ISP(Inteface Segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존 역전 원칙

우선 이렇게만 보고 후에 하나하나 다시 살펴 보자.

```
결합도와 응집도란?

- 결합도: 모듈(클래스)간의 상호 의존 정도, 결합도가 낮다면 모듈 간 상호 의존성이 줄어들므로
객체의 재사용, 수정, 유지보수가 용이하다.

- 응집도: 하나의 모듈 내부에 존재하는 구성 요소들간의 기능적 관련성
->즉 응집도가 높다는 것은 하나의 책임에 집중하고 독립성이 높다는 것, 재사용이나 기능 수정, 유지보수에 용이하다.
```

## SRP - 단일 책임 원칙

```
어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C. 마틴
```

현실 세계에서 어떠한 클래스가 있다면, 그것이 한가지 역할만 하지는 않을 것이다. 그러나 개발에서는?
클래스가 하나의 책임만을 하도록 해야한다는 것이다.

클래스가 여러가지 역할을 하면 책임이 너무 많으므로 피곤해지고, 객체 지향 새계에서는 이럴 경우를 '나쁜 냄새'가 난다고 한다.

어떤 남자 클래스가 있다면, 여자친구에게는 남자친구 역할, 어머니에게는 아들 역할, 직장 상사에게는 사원 역할, 소대장에게는 소대원 역할을 해야 한다. 책임이 너무 많고 상대 클래스와의 관계로 인해 다른 클래스와의 관계가 꼬일 가능성도 있다는 것이다.


그러므로 남자친구가 필요할 땐 남자친구 클래스를, 사원 역할을 할 때는 사원 클래스로, 아들 역할을 할 때는 아들 클래스로, 소대원 역할을 할 때는 소대원 클래스로 나누어 각각의 책임을 나눈 클래스로 구현해야 한다.
그렇다면 이제는 다른 클래스와의 관계로 인해 또 다른 클래스와의 관계가 꼬이지 않는다.

SRP를 지키지 못한 예시는 아래와 같다.

```java
class Human {
	String armyNumber;
    ...
}

...
Human Romeo = new Human();
Human Juliet = new Human();

Juliet.armyNumber = "157371293"; // 이 코드는 잘못되었다.
```
이 가정에서 Juliet은 군대를 갈 의무가 없다고 한다면, 군번을 가지고 있지 않아야 한다. 그러나 Human 클래스 하나에서 책임을 나누지 못한 관계로 Juliet.armyNumber = "157371293"; 라는 잘못된 멤버 변수의 사용이 생겼다.
이럴 경우는, 남자 클래스와 여자 클래스를 나누고/ 남자와 여자의 공통점이 많다면 ->상위 클래스인 Human 클래스에서 이 공통점들을 두고 상속을 받으면 되고, 공통점이 없다면 그냥 Human 클래스를 없애면 된다.

또 다른 예시로는 데이터베이스 에서 테이블에 존재하는 하나의 필드를 이 뜻, 저 뜻으로 사용해서 자바 코드에서 if 문을 사용하며 구별해야하는 경우가 있다. 정규화 과정이라는 것 또한 확장해보면 단일 책임 원칙의 적용이라고 할 수 있다.

메서드가 단일 책임의 원칙을 지키지 못한 경우는 어떤 것이 있을까? 아래와 같다.
```java
class Dog {
	final static Boolean male = true;
    final static Boolean female = false;
    Boolean gender;
    
    void urinate() {
    	if(this.gender == male) {
        	//한 쪽 다리 들고 소변
        } else {
        	//뒷 다리 굽히고 앉은 자세로 소변
        }
    }
   
}
```
이 코드와 같이 수컷, 암컷에 따라 메서드 내에서 if 문으로 처리가 이루어지는 코드는 좋지 않다. 단일 책임 원칙을 지키지 않고 있기 때문이다. 이 코드는 아래와 같이 바꾸어야 한다.


```java
abstract class Dog {
	abstract void urinate()
}

class MaleDog extends Dog {
	void urinate() {
    	//한 쪽 다리 들고 소변
    }
}

class FemaleDog extends Dog {
	void urinate() {
		// 뒷 다리 굽히고 앉은 자세로 소변
    }
}
```

## OCP - 개방 폐쇄 원칙

```text
소프트웨어 엔티티(클래스, 모듈 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.

-> 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
```

간단한 예시는 아래와 같다.
운전자가 기어가 수동인 마티즈를 운전하다가, 기어가 자동인 쏘나타로 바꾸었다면?
분명 마티즈 클래스에서는 [기어수동조작()] 메소드를 사용했는데 쏘나타 클래스는 [기어자동조작()] 메소드를 사용해야 한다. 현실 세계에서는 그렇게 해도 될 지 모르지만, 객체 지향에서의 해결방법은 이와 같다.
자동차라 상위 클래스 또는 인터페이스를 중간에 두어서 다양한 자동차로 바꾼다고 하더라도 운전자가 영향을 받지 않도록 하는 것이다.
이와 마찬가지로 JDBC에서도 클라이언트 데이터베이스를 무엇으로 바꾸든 Connection을 설정하는 부분 외에는 수정할 필요가 없는 것을 둘 수 있다. 즉 확장은 되지만 변화에 대해서는 닫혀 있는 것이다.
책의 초반부에서 살펴보았던, Write Once, Run Anywhere도 마찬가지이다. 운영체제가 변하더라도 구동 될지에 대해서는 걱정하지 않으므로 역시 확장은 되지만, 변화에 대해서는 닫혀 있는 것이다. (목적파일이 완충장치/ 앞선 예에서는 자동차라는 상위 클래스 또는 인터페이스가 완충장치)

## LSP - 리스코프 치환 원칙
```
서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다. - 로버트 C. 마틴
```

- 하위 클래스 is a kind of 상위 클래스: 하위 분류는 상위 분류의 한 종류다.
- 구현 클래스 is able to 인터페이스: 구현 분류는 인터페이스 할 수 있어야 한다.
  위 두 개가 만족된다면 리스코프 치환 원칙을 잘 지키고 있는 것이다.
  특히 첫 문장은, 앞선 내용에서도 살펴보았는데 예시를 들면 아래와 같다.
```java
Animal pororo = new Penguin();
```
이걸 한국어로 읽어본다면? 펭귄 한 마리가 태어나 뽀로로라 이름을 짓고 동물의 행위를 하는데에 무리가 없고 자연스럽다.
그러나 이런 코드는?
```java
아버지 춘향이 = new 딸();
```
딸을 낳아서 이름을 춘향이라 했는데 아빠의 역할을 한다?
춘향이는 아버지형 객체 참조 변수이므로, 아버지 객체가 가진 메소드를 할 수 있어야 하는데 춘향이가 아버지 역할을 한다는 것이 부자연스럽다.

즉 첫번째 예시는 리스코프 치환원칙을 잘 지킨 것이고, 두번째는 지키지 못한 것이다.

```text
하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.
```

앞선 내용에 분류도를 보며 상위클래스, 하위 클래스 개념을 이해했던 것을 떠올려보면, 하위 클래스는 상위클래스의 역할을 할 수 있어야 한다는 것이 떠오를 것이다.(고래는 포유류다, 포유류는 동물이다...)

## ISP - 인터페이스 분리 원칙

```text
클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
```
앞서 살펴보았던 SRP(단일 책임 원칙)의 해결법을 달리한 것이다. 앞선 예시에서 남자 클래스를 각각 남자친구, 아들, 사원, 군인 책임을 가지는 각각의 클래스로 나누었는데 그 대신 남자친구, 아들, 사원, 군인을 인터페이스로 만들고 남자친구 역할이 필요할 땐 인터페이스로 제한, 아들 역할을 할 때는 아들 인터페이스로 제한... 을 하는 것이다.
즉 SRP와 해결법만 다른 것이지 같은 문제에 대해 다루는 것이다.(일반적으론 SRP가 더 좋은 해결책이다.)

- #### 인터페이스 최소주의의 원칙
```
인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메소드만 제공해야 한다.
```
위의 예시에서, 군인 인터페이스에 있는 '사격하기()' 메소드가 남자친구 인터페이스에 제공되어서는 안된다는 것으로 이해할 수 있다.
<br>


- #### 앞서 공부했던 상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋은 이유는?

  빈약한 상위 클래스를 상속했을 경우, 빈번하게 형 변환을 해야 하므로 상속의 장점을 제대로 누리지 못한다.

  인터페이스는 그 역할에 충실하게 만들어야 하지만 다른 역할과 섞이지 않으므로, 작을수록 좋은 것이다.


## DIP - 의존 역전 원칙
```text
- 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화 된 것에 의존해야 한다.
- 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.
- 자주 변경되는 구체 클래스의 의존하지마라.
```
의존 역전 원칙이 적용되지 않았다면...
```
자동차 --> 스노우타이어
```
이런 의존 관계에서, 스노우타이어는 눈이 오지 않는다면 바꿔줘야 한다. 그렇다면 자동차는 그 영향을 받는다. 즉 자동차보다 더 자주 변하는 스노우타이어에 의존해서는 안되는 것이다.
이럴 때는 자동차와 여러 타이어들(스노우타이어, 일반타이어, 광폭타이어) 사이에 타이어 인터페이스를 두어 인터페이스에 자동차가 의존되게 해야한다. 그렇게 되면 자동차는 그 영향을 받지 않게 된다.

여기서 의존 역전 원칙이라는 말을 붙인 이유를 알 수 있다.
처음에는 스노우타이어가 어디에도 의존하지 않았지만, 추상화된 타이어 인터페이스를 추가하고 스노우타이어가 타이어 인터페이스에 의존하게 됐으므로, 의존 관계가 역전 된 것이다.
즉 이를 정리해 한 문장으로 말하면 아래와 같다.
```
자신보다 변하기 쉬운 것에 의존하지 마라.
```


## SOC(Seperation Of Concerns) - 관심사의 분리
```
관심이 같은 것끼리는 하나의 객체 안으로, 또는 친한 객체로 모으고
관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않게 분리하라.
```
하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 하나의 패키지에는 하나의 관심사만 들어야 한다는 것이다. 이것을 계속해서 적용하게 되면 결국 객체 지향 설계 5원칙에 다다르게 된다. 스프링도 SoC를 통해 SOLID를 철저하게 적용하고 있다.

SOLID를 적용하게 되면 다루는 소스 파일 수는 많아지지 않을까? 하는 생각을 자연스럽게 할 수 있다. 그러나 SOLID를 적용하면서 얻는 장점이 훨씬 커서 소스 파일의 갯수에 대한 부담은 덜하다고 할 수 있다.

-  객체지향 세계는 현실세계 같아야 한다.
-  객체 지향 세계는 모델링을 통해 추상화 됐다.
   위 두 문장 중, SOLID는 모델링을 통해 추상화된 것에 초점을 맞추고, 추상화된 객체 지향 세계에 맞는 법도를 따르는 것이다.